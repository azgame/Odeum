#include "NavMeshManager.h"

#include "../Math/Collider.h"
#include "../Math/Plane.h"

#include "../Math/CollisionDetection.h"

#include "../DataStructures/Graph.h"

#include "../Rendering/DirectX12/Model.h"

#include "../Rendering/DirectX12/SceneGraph.h"

#include "delaunator.hpp"

#include <unordered_map>
#include <list>
#include <bitset>

// This seems useful, I'll move it out of here later
struct BitArray
{
	BitArray(size_t Size)
	{
		cellSize = 32;
		m_bitMap.reserve(Size / cellSize);
		std::fill(m_bitMap.begin(), m_bitMap.end(), 0);
	}

	void Reset(size_t Size)
	{
		m_bitMap.clear();
		m_bitMap.resize(Size / cellSize);
		std::fill(m_bitMap.begin(), m_bitMap.end(), 0);
	}

	void Set(uint32_t Pos, bool Val = true)
	{
		ASSERT(Pos < m_bitMap.size() * cellSize, "Value exceeds bounds of bit array");
		uint32_t ArrayCell = Pos / (uint32_t)cellSize;
		uint32_t Index = Pos - (ArrayCell * (uint32_t)cellSize);
		if (Val) m_bitMap[ArrayCell] |= 1UL << Index;
		else m_bitMap[ArrayCell] &= 1UL << ~Index;
	}

	bool Check(uint32_t Pos)
	{
		ASSERT(Pos < m_bitMap.size() * cellSize, "Trying to check bit array value outside bounds of array");
		uint32_t ArrayCell = Pos / (uint32_t)cellSize;
		uint32_t Index = Pos - (ArrayCell * (uint32_t)cellSize);
		return m_bitMap[ArrayCell] & (1UL << Index);
	}

	std::vector<uint32_t> m_bitMap;
	size_t cellSize;
};

struct BitGrid
{
	BitGrid(size_t Width, size_t Height) : m_bitmap(Width * Height)
	{
		width = Width;
		height = Height;
	}

	void Reset(size_t Width, size_t Height)
	{
		m_bitmap.Reset(Width * Height);
		width = Width;
		height = Height;
	}

	void Set(uint32_t X, uint32_t Y, bool Val = true)
	{
		ASSERT(0 <= X && X < width && 0 <= Y && Y < height, "Coordinates given exceed bounds of Bit Grid!");
		m_bitmap.Set(Y * (uint32_t)width + X, Val);
	}

	void Set(Vector2 Coordinate, bool Val = true)
	{
		ASSERT(0 <= Coordinate.GetX() && Coordinate.GetX() < width && 0 <= Coordinate.GetY() && Coordinate.GetY() < height, "Coordinates given exceed bounds of Bit Grid!");
		m_bitmap.Set(Coordinate.GetY() * (uint32_t)width + Coordinate.GetX(), Val);
	}

	bool Check(uint32_t X, uint32_t Y)
	{
		ASSERT(0 <= X && X < width && 0 <= Y && Y < height, "Coordinates given exceed bounds of Bit Grid!");
		return m_bitmap.Check(Y * (uint32_t)width + X);
	}

	size_t width, height;
	BitArray m_bitmap;
};

/* Implementation */
namespace NavMeshManager
{
	BitGrid m_binaryGrid(20, 20);
	std::vector<uint16_t> m_marchingCells;
	std::vector<std::vector<Vector2>> m_contourPoints;
	std::unordered_map<uint16_t, Vector4> lookupMarchingSquares;
	GameObject* navMesh;

	float StartX, StartZ;
	float cellSize;

	void GenerateBinaryImage(float CellSize, uint32_t NumColumns, uint32_t NumRows, Plane GroundPlane, std::vector<Collider2D> Obstacles);
	void CreateContourPoints(float CellSize);
	void RamerDouglasPeuckerPointReduction(std::vector<Vector2>& PointList, float Epsilon);
	std::vector<Vector2> ReduceContourPointsRDP(std::vector<Vector2> PointList, float Epsilon);
	std::vector<double> FormatPointsForTriangulation(std::vector<Vector2>& Points);
	void ReTransformPoints(std::vector<Vector2>& PointList);
	void CullObscuredTris(delaunator::Delaunator& Delauney);
	Model* CreateNavMeshModel(delaunator::Delaunator& Delauney);
	Graph<Vector2>& CreateNavigationData(delaunator::Delaunator& Delauney);
}


// For now just initializing the lookup table for finding the edge lines of a 2x2 cell generated by marching squares
void NavMeshManager::Initialize(float CellSize)
{
	lookupMarchingSquares.reserve(16);
	lookupMarchingSquares[0] = Vector4(kZero);

	lookupMarchingSquares[1] = Vector4(0.5f * CellSize, CellSize, CellSize, 1.5f * CellSize);
	lookupMarchingSquares[2] = Vector4(CellSize, 1.5f * CellSize, 1.5f * CellSize, CellSize);
	lookupMarchingSquares[3] = Vector4(0.5f * CellSize, CellSize, 1.5f * CellSize, CellSize);
	lookupMarchingSquares[4] = Vector4(1.5f * CellSize, CellSize, CellSize, 0.5f * CellSize);

	lookupMarchingSquares[5] = Vector4(kZero); // saddle point, ignore for now

	lookupMarchingSquares[6] = Vector4(CellSize, 1.5f * CellSize, CellSize, 0.5f * CellSize);
	lookupMarchingSquares[7] = Vector4(0.5f * CellSize, CellSize, CellSize, 0.5f * CellSize);
	lookupMarchingSquares[8] = Vector4(CellSize, 0.5f * CellSize, 0.5f * CellSize, CellSize);
	lookupMarchingSquares[9] = Vector4(CellSize, 0.5f * CellSize, CellSize, 1.5f * CellSize);

	lookupMarchingSquares[10] = Vector4(kZero); // saddle point, ignore for now

	lookupMarchingSquares[11] = Vector4(CellSize, 0.5f * CellSize, 1.5f * CellSize, CellSize);
	lookupMarchingSquares[12] = Vector4(1.5f * CellSize, CellSize, 0.5f * CellSize, CellSize);
	lookupMarchingSquares[13] = Vector4(1.5f * CellSize, CellSize, CellSize, 1.5f * CellSize); //
	lookupMarchingSquares[14] = Vector4(CellSize, 1.5f * CellSize, 0.5f * CellSize, CellSize);

	lookupMarchingSquares[15] = Vector4(kZero);
}

// Might not use Colliders in interface yet, going to start by grabbing obbs from scene and translating them into colliders (slow) and speed it up later
// A necessary optimization will be to spatially partition/order obstacles (preferably using BVH)
void NavMeshManager::GenerateNavMesh(float CellSize, Plane GroundPlane, std::vector<Collider2D> Obstacles)
{
	// For now...
	ASSERT(GroundPlane.normal == Vector3(kYUnitVector), "For now, we are only accepting planes which lie 'flat' and face 'up'");

	cellSize = CellSize;

	Initialize(CellSize);

	// Get plane size (GroundPlane min/max divided by CellSize)
	uint32_t totalWidth, totalHeight;
	totalWidth = (uint32_t)(GroundPlane.max.GetX() - GroundPlane.min.GetX());
	totalHeight = (uint32_t)(GroundPlane.max.GetZ() - GroundPlane.min.GetZ());

	StartX = GroundPlane.min.GetX();
	StartZ = GroundPlane.min.GetZ();

	// Determine max extent via CellSize
	uint32_t numColumns, numRows;
	numColumns = (float)totalWidth / CellSize;
	numRows = (float)totalHeight / CellSize;

	m_binaryGrid.Reset(numColumns, numRows);
	m_marchingCells.reserve((numRows - 1) * (numColumns - 1));

	// Collider2D* cachedCollider = nullptr;

	// Start at 0, 0 in plane local space. Step +x CellSize. Create collider2D starting at Step position (min) and extent of cell (CellSize + x, CellSize + y)
	// TODO Aidan: Parallelize this later
	for (UINT j = 0; j < numRows; j++)
	{
		for (UINT i = 0; i < numColumns; i++)
		{
			Collider2D cell = 
			{ 
				/*BL*/ Vector2(i * CellSize + StartX, j * CellSize + StartZ), 
				/*BR*/ Vector2(i * CellSize + CellSize + StartX, j * CellSize + StartZ),
				/*TL*/ Vector2(i * CellSize + StartX, j * CellSize + CellSize + StartZ),
				/*TR*/ Vector2(i * CellSize + CellSize + StartX, j * CellSize + CellSize + StartZ)
			};

			// If in the last loop we collided, we cache the collider we hit for faster lookup in the next frame 
			// since its likely that it will be a part of a larger contiguous shape
			/*if (cachedCollider != nullptr)
			{
				if (!CollisionDetection::GJKCollisionDetection2D(&cell, cachedCollider))
				{
					m_binaryGrid.Set(i, j);
					std::cout << "X";
					continue;
				}
			}*/

			bool collision = false;

			// Check collision of collider 2D against Obstacles, setting bitgrid at index if collision 
			for (auto c : Obstacles)
			{
				//if (cachedCollider == &c) // skip the collider that we've already checked
				//	continue;

				if (CollisionDetection::GJKCollisionDetection2D(&cell, &c))
				{
					// cachedCollider = &c;
					m_binaryGrid.Set(i, j);
					collision = true;
					break;
				}
			}

			/*if (!collision)
			{
				cachedCollider = nullptr;
			}	*/
		}
	}

	for (int j = numRows - 1; j >= 0; j--)
	{
		for (int i = 0; i < numColumns; i++)
		{
			if (m_binaryGrid.Check(i, j))
			{
				std::cout << "O";
			}
			else
			{
				std::cout << "*";
			}
		}
		std::cout << "" << std::endl;
	}

	CreateContourPoints(CellSize);

	std::vector<double> triangulationPoints;

	for (int i = 0; i < m_contourPoints.size(); i++)
	{
		RamerDouglasPeuckerPointReduction(m_contourPoints[i], 0.25f);

		ReTransformPoints(m_contourPoints[i]);

		std::vector<double> addedPoints = FormatPointsForTriangulation(m_contourPoints[i]);

		triangulationPoints.insert(triangulationPoints.end(), addedPoints.begin(), addedPoints.end());
	}

	triangulationPoints.push_back(StartX);
	triangulationPoints.push_back(StartZ);
	triangulationPoints.push_back(StartX + (float)totalWidth);
	triangulationPoints.push_back(StartZ);
	triangulationPoints.push_back(StartX);
	triangulationPoints.push_back(StartZ + (float)totalHeight);
	triangulationPoints.push_back(StartX + (float)totalWidth);
	triangulationPoints.push_back(StartZ + (float)totalHeight);

	delaunator::Delaunator delauney(triangulationPoints);

	// Check if tris are inside object boundaries (check centroid against binary image) and cull if they are
	CullObscuredTris(delauney);

	// For pathfinding, will need to make sure destination lies within nav mesh, and if it does, find shortest path to point from nav data
	Graph<Vector2> pathfindingData = CreateNavigationData(delauney);

	Model* model = CreateNavMeshModel(delauney);

	navMesh = new GameObject(model);

	// cachedCollider = nullptr;
}

// For later
void NavMeshManager::GenerateBinaryImage(float CellSize, uint32_t NumColumns, uint32_t NumRows, Plane GroundPlane, std::vector<Collider2D> Obstacles)
{
}

/*
	March completed binary image. March along contours given direction from start->end of contour line. Once we reach original start, close contour line and save collection to d.s.
*/
// This is our "once completed" contouring. Might try to parallelize this later
void NavMeshManager::CreateContourPoints(float CellSize)
{
	// iterate through grid in 2x2s. If we find a new contour, begin a new list with it as start and end. "Walk" the contour line by getting the next 2x2, 
	//	informed by the direction of end->start

	// Copy binary grid so we can safely overwrite values while creating contouring lines
	BitGrid binaryImage = m_binaryGrid;

	uint32_t width, height;
	width = binaryImage.width;
	height = binaryImage.height;

	for (uint32_t j = 1; j < height; j++)
	{
		for (uint32_t i = 1; i < width; i++)
		{
			uint32_t X, Z;
			X = i - 1;
			Z = j - 1;

			uint16_t bit = 0;
			bit |= binaryImage.Check(X++, Z) ? 0 : 1UL << 3; // msb
			bit |= binaryImage.Check(X, Z++) ? 0 : 1UL << 2;
			bit |= binaryImage.Check(X--, Z) ? 0 : 1UL << 1;
			bit |= binaryImage.Check(X, Z) ? 0 : 1UL; // lsb

			Vector4 bitLine = lookupMarchingSquares[bit];

			if (bitLine == Vector4(kZero))
				continue;

			// Start moving along the contour
			Vector2 start = Vector2(bitLine.GetX() + ((i - 1) * CellSize), bitLine.GetY() + ((j - 1) * CellSize));
			Vector2 end = Vector2(bitLine.GetZ() + ((i - 1) * CellSize), bitLine.GetW() + ((j - 1) * CellSize));

			m_contourPoints.push_back({ start, end });
			size_t objectIndex = m_contourPoints.size() - 1;

			std::unordered_map<uint32_t, std::pair<uint32_t, uint32_t>> outerWalls;
			outerWalls[j] = { i, i };

			uint32_t xPos, zPos;
			xPos = i;
			zPos = j;

			if (bitLine.GetZ() == CellSize)
			{
				zPos += bitLine.GetW() > CellSize ? 1 : (bitLine.GetW() < CellSize ? -1 : 0);
			}
			else if (bitLine.GetW() == CellSize)
			{
				xPos += bitLine.GetZ() > CellSize ? 1 : (bitLine.GetZ() < CellSize ? -1 : 0);
			}

			// Move along the contour until we reach the beginning
			while (xPos != i || zPos != j)
			{
				// Construct a new 2x2 around end point
				X = xPos - 1;
				Z = zPos - 1;

				ASSERT(0 <= X && X < width - 1 && 0 <= Z && Z < height - 1, "Went outside bounds of grid");

				// We are building the min and max x points for each row so that when we go to clear the binary image, we know
				//	exactly how much to delete
				auto it = outerWalls.find(zPos);
				if (it != outerWalls.end()) 
				{
					// stuff
					if (xPos < it->second.first)
						it->second.first = xPos;
					if (xPos > it->second.second)
						it->second.second = xPos;
				}
				else
				{
					outerWalls[zPos] = { xPos, xPos };
				}

				bit = 0;
				bit |= binaryImage.Check(X++, Z) ? 0 : 1UL << 3; // msb
				bit |= binaryImage.Check(X, Z++) ? 0 : 1UL << 2;
				bit |= binaryImage.Check(X--, Z) ? 0 : 1UL << 1;
				bit |= binaryImage.Check(X, Z) ? 0 : 1UL; // lsb

				bitLine = lookupMarchingSquares[bit];

				if (bitLine == Vector4(kZero))
				{
					ERROR("This shouldn't happen");
				}
					
				start = Vector2(bitLine.GetX() + ((xPos - 1) * CellSize), bitLine.GetY() + ((zPos - 1) * CellSize));
				end = Vector2(bitLine.GetZ() + ((xPos - 1) * CellSize), bitLine.GetW() + ((zPos - 1) * CellSize));

				m_contourPoints[objectIndex].push_back(end);

				if (bitLine.GetZ() == CellSize)
				{
					zPos += bitLine.GetW() > CellSize ? 1 : (bitLine.GetW() < CellSize ? -1 : 0);
				}
				else if (bitLine.GetW() == CellSize)
				{
					xPos += bitLine.GetZ() > CellSize ? 1 : (bitLine.GetZ() < CellSize ? -1 : 0);
				}
			}

			// erase the object from the temp binary image
			for (auto row : outerWalls)
			{
				for (int i = row.second.first; i < row.second.second; i++)
				{
					binaryImage.Set(i, row.first, false);
				}
			}
		}
	}
}

void NavMeshManager::RamerDouglasPeuckerPointReduction(std::vector<Vector2>& PointList, float Epsilon)
{
	auto halfway = PointList.begin() + (PointList.size() / 2);

	std::vector<Vector2> firstHalf = ReduceContourPointsRDP(std::vector<Vector2>(PointList.begin(), halfway), Epsilon);
	std::vector<Vector2> secondHalf = ReduceContourPointsRDP(std::vector<Vector2>(halfway, PointList.end() - 1), Epsilon);

	PointList.clear();
	PointList.insert(PointList.end(), firstHalf.begin(), firstHalf.end());
	PointList.insert(PointList.end(), secondHalf.begin(), secondHalf.end());
}

std::vector<Vector2> NavMeshManager::ReduceContourPointsRDP(std::vector<Vector2> PointList, float Epsilon)
{
	// Created from Ramer-Douglas-Peucker pseudocode found at https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm

	float dmax = 0;
	uint32_t index = 0;
	size_t end = PointList.size() - 1;

	for (int i = 1; i < end; i++)
	{
		double d = Math::PerpendicularDistance(PointList[i], PointList[0], PointList[end]);
		if (d > dmax)
		{
			index = i;
			dmax = d;
		}
	}

	std::vector<Vector2> finalList;

	if (dmax > Epsilon)
	{
		std::vector<Vector2> results1 = ReduceContourPointsRDP(std::vector<Vector2>(PointList.begin(), PointList.begin() + index), Epsilon);
		std::vector<Vector2> results2 = ReduceContourPointsRDP(std::vector<Vector2>(PointList.begin() + index, PointList.end()), Epsilon);

		finalList.reserve(results1.size() + results2.size());
		finalList.insert(finalList.end(), results1.begin(), results1.end());
		finalList.insert(finalList.end(), results2.begin(), results2.end());
	}
	else
	{
		finalList = std::vector<Vector2>({ PointList[0], PointList[end] });
	}

	return finalList;
}

std::vector<double> NavMeshManager::FormatPointsForTriangulation(std::vector<Vector2>& Points)
{
	std::vector<double> coords;

	for (auto Point : Points)
	{
		coords.push_back(Point.GetX());
		coords.push_back(Point.GetY());
	}

	return coords;
}

void NavMeshManager::ReTransformPoints(std::vector<Vector2>& PointList)
{
	for (int i = 0; i < PointList.size(); i++)
	{
		PointList[i].SetX(PointList[i].GetX() + StartX);
		PointList[i].SetY(PointList[i].GetY() + StartZ);
	}
}

void NavMeshManager::CullObscuredTris(delaunator::Delaunator& Delauney)
{
	ASSERT(Delauney.triangles.size() % 3 == 0, "Just making sure our list of triangles is of base 3");

	std::vector<size_t> trisToKeep;

	for (int i = 0; i < Delauney.triangles.size(); i += 3)
	{
		double x0 = Delauney.coords[2 * Delauney.triangles[i]];			// x0
		double y0 = Delauney.coords[2 * Delauney.triangles[i] + 1];		// y0
		double x1 = Delauney.coords[2 * Delauney.triangles[i + 1]];		// x1
		double y1 = Delauney.coords[2 * Delauney.triangles[i + 1] + 1];	// y1
		double x2 = Delauney.coords[2 * Delauney.triangles[i + 2]];		// x2
		double y2 = Delauney.coords[2 * Delauney.triangles[i + 2] + 1]; // y2

		double centroidX = (x0 + x1 + x2) / 3.0; 
		double centroidY = (y0 + y1 + y2) / 3.0;

		if (!m_binaryGrid.Check((uint32_t)((centroidX - StartX) / cellSize), (uint32_t)((centroidY - StartZ) / cellSize)))
		{
			trisToKeep.push_back(Delauney.triangles[i]);
			trisToKeep.push_back(Delauney.triangles[i + 1]);
			trisToKeep.push_back(Delauney.triangles[i + 2]);
		}
	}

	Delauney.triangles = trisToKeep;
}

Model* NavMeshManager::CreateNavMeshModel(delaunator::Delaunator& Delauney)
{
	Model* model = new Model();

	model->m_details.meshCount = 1;
	model->m_details.materialCount = 1;
	model->m_pMaterials = new Model::Material[1];
	model->m_pMesh = new Model::Mesh[1];

	model->m_pVertexData = new Vertex[Delauney.coords.size() / 2];
	model->m_vertexStride = sizeof(float) * 14;
	model->m_details.vertexCount = Delauney.coords.size() / 2;

	Vertex* vertex = model->m_pVertexData;

	for (int i = 0; i < Delauney.coords.size(); i+=2)
	{
		// position - coords.x, 1, coords.z
		vertex->position = DirectX::XMFLOAT3(Delauney.coords[i], -2.0f, Delauney.coords[i + 1]);
		// normal - 0, 1, 0
		vertex->normal = DirectX::XMFLOAT3(0, 1, 0);
		// uv - 0, 1
		vertex->uvcoords = DirectX::XMFLOAT2(0, 1);
		// tangent - 1, 0, 0
		vertex->tangent = DirectX::XMFLOAT3(1, 0, 0);
		// bitangent - 0, 0, 1
		vertex->bitangent = DirectX::XMFLOAT3(0, 0, 1);

		vertex++;
	}

	model->m_pIndexData = new uint16_t[Delauney.triangles.size()];
	model->m_details.indexCount = Delauney.triangles.size();

	uint16_t* indice = model->m_pIndexData;

	model->m_pMesh[0].indexCount = model->m_details.indexCount;
	model->m_pMesh[0].indexOffset = 0;
	model->m_pMesh[0].vertexCount = model->m_details.vertexCount;
	model->m_pMesh[0].vertexStride = model->m_vertexStride;
	model->m_pMesh[0].vertexOffset = 0;
	model->m_pMesh[0].materialIndex = 0;

	// indices (triangles)
	for (int i = 0; i < Delauney.triangles.size(); i++)
	{
		*indice++ = Delauney.triangles[i];
	}

	model->m_vertexBuffer.Create("Vertex buffer", model->m_details.vertexCount, model->m_vertexStride, model->m_pVertexData);
	model->m_indexBuffer.Create("Index buffer", model->m_details.indexCount, sizeof(uint16_t), model->m_pIndexData);
	model->m_flatColour = Colour(0.2f, 0.2f, 1.0f);

	// colour texture
	model->LoadTextures();

	model->isLoaded = true;

	return model;
}

Graph<Vector2>& NavMeshManager::CreateNavigationData(delaunator::Delaunator& Delauney)
{
	Graph<Vector2> pathfindingData(Delauney.triangles.size() / 3);

	// slow way
	// for each triangle, calculate circumcircle
	// if another triangle contains 2 of the same edges, they are neighbours
	// Calculate circumcircle for that triangle, and add to connectivity graph

	for (int index = 0; index < Delauney.triangles.size(); index += 3)
	{
		int foundCount = 0;

		double x0 = Delauney.coords[2 * Delauney.triangles[index]];			// x0
		double y0 = Delauney.coords[2 * Delauney.triangles[index] + 1];		// y0
		double x1 = Delauney.coords[2 * Delauney.triangles[index + 1]];		// x1
		double y1 = Delauney.coords[2 * Delauney.triangles[index + 1] + 1];	// y1
		double x2 = Delauney.coords[2 * Delauney.triangles[index + 2]];		// x2
		double y2 = Delauney.coords[2 * Delauney.triangles[index + 2] + 1]; // y2

		// Determine three angles
		Vector2 a = Vector2(x0, y0);
		Vector2 b = Vector2(x1, y1);
		Vector2 c = Vector2(x2, y2);

		float angleA = acos(Math::Dot(b, c) / (b.Mag() * c.Mag()));
		float angleB = acos(Math::Dot(a, c) / (a.Mag() * c.Mag()));
		float angleC = acos(Math::Dot(a, b) / (a.Mag() * b.Mag()));

		// Calculate circumcenter
		Vector2 cCenter = Vector2((x0 * sin(2 * angleA) + x1 * sin(2 * angleB) + x2 * sin(2 * angleC)) / (sin(2 * angleA) + sin(2 * angleB) + sin(2 * angleC)),
			(y0 * sin(2 * angleA) + y1 * sin(2 * angleB) + y2 * sin(2 * angleC)) / (sin(2 * angleA) + sin(2 * angleB) + sin(2 * angleC)));

		if (!pathfindingData.contains(cCenter))
			pathfindingData.push(cCenter);

		for (int j = 0; j < Delauney.triangles.size(); j += 3)
		{
			if (index == j)
				continue;

			int similarVertices = 0;

			// Create triangle vertices
			x0 = Delauney.coords[2 * Delauney.triangles[j]];			// x0
			y0 = Delauney.coords[2 * Delauney.triangles[j] + 1];		// y0
			x1 = Delauney.coords[2 * Delauney.triangles[j + 1]];		// x1
			y1 = Delauney.coords[2 * Delauney.triangles[j + 1] + 1];	// y1
			x2 = Delauney.coords[2 * Delauney.triangles[j + 2]];		// x2
			y2 = Delauney.coords[2 * Delauney.triangles[j + 2] + 1];	// y2

			Vector2 otherA = Vector2(x0, y0);
			Vector2 otherB = Vector2(x1, y1);
			Vector2 otherC = Vector2(x2, y2);

			// if two of the vertices match with "index", then these triangles are neighbours
			if (a == otherA || a == otherB || a == otherC)
				similarVertices++;

			if (b == otherA || b == otherB || b == otherC)
				similarVertices++;

			if (c == otherA || c == otherB || c == otherC)
				similarVertices++;

			if (similarVertices < 2)
				continue;

			// Determine three angles
			angleA = acos(Math::Dot(otherB, otherC) / (otherB.Mag() * otherC.Mag()));
			angleB = acos(Math::Dot(otherA, otherC) / (otherA.Mag() * otherC.Mag()));
			angleC = acos(Math::Dot(otherA, otherB) / (otherA.Mag() * otherB.Mag()));

			// Calculate circumcenter
			Vector2 otherCCenter = Vector2((x0 * sin(2 * angleA) + x1 * sin(2 * angleB) + x2 * sin(2 * angleC)) / (sin(2 * angleA) + sin(2 * angleB) + sin(2 * angleC)),
				(y0 * sin(2 * angleA) + y1 * sin(2 * angleB) + y2 * sin(2 * angleC)) / (sin(2 * angleA) + sin(2 * angleB) + sin(2 * angleC)));
			
			// Add graph edge between two circumcenters
			if (!pathfindingData.contains(otherCCenter))
				pathfindingData.push(otherCCenter);

			pathfindingData.attachEdge(cCenter, otherCCenter);
		}
	}

	return pathfindingData;
}

void NavMeshManager::Uninitialize()
{
}